<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>async await 是把双刃剑</title>
      <link href="/2022/10/08/async%20await%20%E5%8F%8C%E5%88%83%E5%89%91/"/>
      <url>/2022/10/08/async%20await%20%E5%8F%8C%E5%88%83%E5%89%91/</url>
      
        <content type="html"><![CDATA[<p>本周精读内容是 <a href="https://medium.freecodecamp.org/avoiding-the-async-await-hell-c77a0fb71c4c">《async&#x2F;await 是把双刃剑》</a>。</p><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h2><p>终于，async&#x2F;await 也被吐槽了。Aditya Agarwal 认为 async&#x2F;await 语法让我们陷入了新的麻烦之中。</p><p>其实，笔者也早就觉得哪儿不对劲了，终于有个人把实话说了出来，async&#x2F;await 可能会带来麻烦。</p><h2 id="2-概述"><a href="#2-概述" class="headerlink" title="2 概述"></a>2 概述</h2><p>下面是随处可见的现代化前端代码：</p><pre><code class="typescript">(async () =&gt; &#123;  const pizzaData = await getPizzaData(); // async call  const drinkData = await getDrinkData(); // async call  const chosenPizza = choosePizza(); // sync call  const chosenDrink = chooseDrink(); // sync call  await addPizzaToCart(chosenPizza); // async call  await addDrinkToCart(chosenDrink); // async call  orderItems(); // async call&#125;)();</code></pre><p>await 语法本身没有问题，有时候可能是使用者用错了。当 <code>pizzaData</code> 与 <code>drinkData</code> 之间没有依赖时，顺序的 await 会最多让执行时间增加一倍的 <code>getPizzaData</code> 函数时间，因为 <code>getPizzaData</code> 与 <code>getDrinkData</code> 应该并行执行。</p><p>回到我们吐槽的回调地狱，虽然代码比较丑，带起码两行回调代码并不会带来阻塞。</p><p>看来语法的简化，带来了性能问题，而且直接影响到用户体验，是不是值得我们反思一下？</p><p>正确的做法应该是先同时执行函数，再 await 返回值，这样可以并行执行异步函数：</p><pre><code class="typescript">(async () =&gt; &#123;  const pizzaPromise = selectPizza();  const drinkPromise = selectDrink();  await pizzaPromise;  await drinkPromise;  orderItems(); // async call&#125;)();</code></pre><p>或者使用 <code>Promise.all</code> 可以让代码更可读：</p><pre><code class="typescript">(async () =&gt; &#123;  Promise.all([selectPizza(), selectDrink()]).then(orderItems); // async call&#125;)();</code></pre><p>看来不要随意的 await，它很可能让你代码性能降低。</p><h2 id="3-精读"><a href="#3-精读" class="headerlink" title="3 精读"></a>3 精读</h2><p>仔细思考为什么 async&#x2F;await 会被滥用，笔者认为是它的功能比较反直觉导致的。</p><p>首先 async&#x2F;await 真的是语法糖，功能也仅是让代码写的舒服一些。先不看它的语法或者特性，仅从语法糖三个字，就能看出它一定是局限了某些能力。</p><p>举个例子，我们利用 html 标签封装了一个组件，带来了便利性的同时，其功能一定是 html 的子集。又比如，某个轮子哥觉得某个组件 api 太复杂，于是基于它封装了一个语法糖，我们多半可以认为这个便捷性是牺牲了部分功能换来的。</p><p>功能完整度与使用便利度一直是相互博弈的，很多框架思想的不同开源版本，几乎都是把功能完整度与便利度按照不同比例混合的结果。</p><p>那么回到 async&#x2F;await 它的解决的问题是回调地狱带来的灾难：</p><pre><code class="typescript">a(() =&gt; &#123;  b(() =&gt; &#123;    c();  &#125;);&#125;);</code></pre><p>为了减少嵌套结构太多对大脑造成的冲击，async&#x2F;await 决定这么写：</p><pre><code class="typescript">await a();await b();await c();</code></pre><p>虽然层级上一致了，但逻辑上还是嵌套关系，这不是另一个程度上增加了大脑负担吗？而且这个转换还是隐形的，所以许多时候，我们倾向于忽略它，所以造成了语法糖的滥用。</p><h3 id="理解语法糖"><a href="#理解语法糖" class="headerlink" title="理解语法糖"></a>理解语法糖</h3><p>虽然要正确理解 async&#x2F;await 的真实效果比较反人类，但为了清爽的代码结构，以及防止写出低性能的代码，还是挺有必要认真理解 async&#x2F;await 带来的改变。</p><p>首先 async&#x2F;await 只能实现一部分回调支持的功能，也就是仅能方便应对层层嵌套的场景。其他场景，就要动一些脑子了。</p><p>比如两对回调：</p><pre><code class="typescript">a(() =&gt; &#123;  b();&#125;);c(() =&gt; &#123;  d();&#125;);</code></pre><p>如果写成下面的方式，虽然一定能保证功能一致，但变成了最低效的执行方式：</p><pre><code class="typescript">await a();await b();await c();await d();</code></pre><p>因为翻译成回调，就变成了：</p><pre><code class="typescript">a(() =&gt; &#123;  b(() =&gt; &#123;    c(() =&gt; &#123;      d();    &#125;);  &#125;);&#125;);</code></pre><p>然而我们发现，原始代码中，函数 <code>c</code> 可以与 <code>a</code> 同时执行，但 async&#x2F;await 语法会让我们倾向于在 <code>b</code> 执行完后，再执行 <code>c</code>。</p><p>所以当我们意识到这一点，可以优化一下性能：</p><pre><code class="typescript">const resA = a();const resC = c();await resA;b();await resC;d();</code></pre><p>但其实这个逻辑也无法达到回调的效果，虽然 <code>a</code> 与 <code>c</code> 同时执行了，但 <code>d</code> 原本只要等待 <code>c</code> 执行完，现在如果 <code>a</code> 执行时间比 <code>c</code> 长，就变成了:</p><pre><code class="typescript">a(() =&gt; &#123;  d();&#125;);</code></pre><p>看来只有完全隔离成两个函数：</p><pre><code class="typescript">(async () =&gt; &#123;  await a();  b();&#125;)();(async () =&gt; &#123;  await c();  d();&#125;)();</code></pre><p>或者利用 <code>Promise.all</code>:</p><pre><code class="typescript">async function ab() &#123;  await a();  b();&#125;async function cd() &#123;  await c();  d();&#125;Promise.all([ab(), cd()]);</code></pre><p>这就是我想表达的可怕之处。回调方式这么简单的过程式代码，换成 async&#x2F;await 居然写完还要反思一下，再反推着去优化性能，这简直比回调地狱还要可怕。</p><p>而且大部分场景代码是非常复杂的，同步与 await 混杂在一起，想捋清楚其中的脉络，并正确优化性能往往是很困难的。但是我们为什么要自己挖坑再填坑呢？很多时候还会导致忘了填。</p><p>原文作者给出了 <code>Promise.all</code> 的方式简化逻辑，但笔者认为，不要一昧追求 async&#x2F;await 语法，在必要情况下适当使用回调，是可以增加代码可读性的。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>async&#x2F;await 回调地狱提醒着我们，不要过度依赖新特性，否则可能带来的代码执行效率的下降，进而影响到用户体验。同时，笔者认为，也不要过度利用新特性修复新特性带来的问题，这样反而导致代码可读性下降。</p><p>当我翻开 redux 刚火起来那段时期的老代码，看到了许多过度抽象、为了用而用的代码，硬是把两行代码能写完的逻辑，拆到了 3 个文件，分散在 6 行不同位置，我只好用字符串搜索的方式查找线索，最后发现这个抽象代码整个项目仅用了一次。</p><p>写出这种代码的可能性只有一个，就是在精神麻木的情况下，一口气喝完了 redux 提供的全部鸡汤。</p><p>就像 async&#x2F;await 地狱一样，看到这种 redux 代码，我觉得远不如所谓没跟上时代的老前端写出的 jquery 代码。</p><p>决定代码质量的是思维，而非框架或语法，async&#x2F;await 虽好，但也要适度哦。</p><blockquote><p>PS: 经过讨论，笔者把原文 async&#x2F;await 地狱标题改成了 async&#x2F;await 是把双刃剑。因为 async&#x2F;await 并没有回调地狱那么可怕，称它为地狱有误导的可能性。</p></blockquote><h2 id="5-更多讨论"><a href="#5-更多讨论" class="headerlink" title="5 更多讨论"></a>5 更多讨论</h2><blockquote><p>讨论地址是：<a href="https://github.com/dt-fe/weekly/issues/82">精读《async&#x2F;await 是把双刃剑》 · Issue #82 · dt-fe&#x2F;weekly</a></p></blockquote><p><strong>如果你想参与讨论，请<a href="https://github.com/dt-fe/weekly">点击这里</a>，每周都有新的主题，周末或周一发布。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Js Es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql知识点</title>
      <link href="/2022/10/06/%E6%95%B0%E6%8D%AE%E5%BA%93(mysql_mongo)/"/>
      <url>/2022/10/06/%E6%95%B0%E6%8D%AE%E5%BA%93(mysql_mongo)/</url>
      
        <content type="html"><![CDATA[<h3 id="mysql数据库"><a href="#mysql数据库" class="headerlink" title="mysql数据库"></a>mysql数据库</h3><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><pre><code>- 数据类型    + 整数类型 int    + 浮点类型 double    + 日期类型 date/timestamp     + 字符串类型 char varchar        * 可变varchar(n)  必须要给字符最大长度n 使用：用户名，密码，身份证号码。 n= 40 40 个字节，20个字符         * 不可变是char 不需要给字符长度,使用；商品描述、歌词...        * 空间换时间         * text 长度不限 - 首先足够用，其次尽量小</code></pre><pre><code>    create table 表名(        id int,        name varchar(20)    );</code></pre><pre><code>- 查看创建表的语句    + show create table 表名- 查看表的明细    + desc 表名</code></pre><h4 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h4><pre><code>- drop table 表名</code></pre><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><pre><code>- 第一种：全表字段插入    + `insert into 表名 values (val1,val2...)`    + 插入的字段类型和*顺序必须*与表的字段*类型*与顺序保持一致,个数是针对全表字段的插入- 指定表字段的插入    + `insert into 表名 (字段1,字段2...) values (val1,val2...)`    + 插入的数据的顺序要与声明的字段名的顺序一致    + 类型也要一致，个数也要一致</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>sql 语句 结尾必须要有  分号</p><ul><li>启动：到安装的bin文件下 或者用可视化工具</li></ul><ul><li>1: 登录：<ul><li>mysql   -u root -p</li><li>密码</li><li><code>mysql 连接 -u用户名root -p</code></li><li>mysql  -hlocalhost -uroot -p</li><li><code>mysql yanqi -uroot -p</code></li></ul></li><li>2: 查看有哪些数据库<ul><li>show databases;</li></ul></li><li>3: 切换数据库<ul><li>use 数据库名;</li></ul></li><li>4: show tables;  <ul><li>没有表： 必须创建表 create table ceshi(id int,name varchar(20));</li></ul></li><li>5: 查看表字段明细<ul><li>desc 表名;</li></ul></li><li>6: 插入数据<ul><li><code>insert into 表名 (字段1,..) values (值1...)</code></li><li>插入的是数据，表中字段；以及字段的类型；是在创建表示决定的</li></ul></li><li>更新操作<ul><li><code>UPDATE 表名 SET 字段1 = 表达式,[,字段2 = 表达式] [WHERE express布尔值]</code></li><li><code> update student set tmp = 20+1,sex = sex where 1=1;</code></li></ul></li><li>删除操作<ul><li><code>DELETE FROM 表名 [,WHERE exr布尔值]</code></li><li><code>delete from student where name = &#39;马蓉&#39;;</code></li></ul></li><li>truncate和delete的区别<ul><li><code>truncate table 表名</code><br>  delete会一条一条的删 自增id保留<br>  truncate先摧毁整张表，再创建一张和原来的表结构一模一样的表<br>  truncate在效率上比delete高<br>  truncate只能删除整表的数据，也就是格式化。<br>  truncate会把自增id截断恢复为1</li></ul></li></ul><h3 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h3><ul><li>DISTINCT 去重，尽量不要根据* 来去重<ul><li><code>select distinct name,age from student;</code></li></ul></li><li>查询语句可以指定多个字段查询，也可以使用* 查询<ul><li>在企业中，使用SQL查询* 是会拉低查询效率的 ，建议少用* 查询</li></ul></li></ul><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><ul><li><code>select * from student where math &gt; 66.6 or math &lt; 66.6;</code></li><li>语法：select * from 表 查询条件</li></ul><pre><code>&gt; &lt; &lt;= &gt;= = &lt;&gt;    大于、小于、大于(小于等于)、不等于between...and 显示在某一区间的值in(set) 显示在in列表中的值，例：in(100,200)like ‘张pattern’ 模糊查询%is null 判断是否为空and 多个条件同时成立or  多个条件任一成立not 不成立，例：where not(salary&gt;100)</code></pre><h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><pre><code>- 包含关`select * from student where name like &#39;%关%&#39;;` - 以关开头`select * from student where name like &#39;关%&#39;;` - 以关结尾`select * from student where name like &#39;%关&#39;;` </code></pre><ul><li>判断为空<ul><li><code>select * from student where sex is not null;</code></li></ul></li></ul><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><ul><li>统计数量 <ul><li>count(星号)</li></ul></li><li>求和<ul><li>sum(math+english+chinese)</li></ul></li><li>平均值<ul><li>avg(math+english+chinese)</li></ul></li><li>找最值<ul><li>max(列)&#x2F;min(列)&#x2F;max(math+english+chinese)</li></ul></li></ul><h4 id="排序-order-by"><a href="#排序-order-by" class="headerlink" title="排序(order by)"></a>排序(order by)</h4><ul><li><code>select * from student where 1= 1 order by chinese desc,math desc,english desc;</code></li></ul><h4 id="分组-group-by"><a href="#分组-group-by" class="headerlink" title="分组(group by)"></a>分组(group by)</h4><ul><li>如果聚合函数只有一行，需要对于不同的集合做聚合运算就加上分组<ul><li><code>select zu,count(*) from student group by zu;</code></li></ul></li></ul><h4 id="分页-limit"><a href="#分页-limit" class="headerlink" title="分页(limit)"></a>分页(limit)</h4><pre><code>    - `select * from student limit 10,5;`    - limit offset(起始位置) count(显示多少个)    - limit 使用的时候，offset从0开始    - 豆瓣： offset （当前页-1）* 页显示数        + count ： 页显示数</code></pre><h4 id="默认端口（数据库汇总）"><a href="#默认端口（数据库汇总）" class="headerlink" title="默认端口（数据库汇总）"></a>默认端口（数据库汇总）</h4><ul><li>oracle：1521</li><li>sqlserver ：1433</li><li>mysql ：3306</li><li>mongodb ：27017</li><li>DB2 ： 50000</li></ul><h3 id="mysql中间使用"><a href="#mysql中间使用" class="headerlink" title="mysql中间使用"></a>mysql中间使用</h3><h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><ul><li><input disabled="" type="checkbox"> 1：导入mysql 中间件  const mysql &#x3D; require(‘mysql’);</li><li><input disabled="" type="checkbox"> 2: 创建连接池  const pool &#x3D;mysql.createPool()</li><li><input disabled="" type="checkbox"> 3: 取出链接  pool.getConnection()</li><li><input disabled="" type="checkbox"> 4：操作数据 pool.query()</li><li><input disabled="" type="checkbox"> 5：释放链接  release()</li><li><input disabled="" type="checkbox"> 6：操作数据库完毕（err&#x2F;success） 做什么(交给外部处理函数)</li></ul><p>mysql中间件操作mysql 数据库方法封装</p><pre><code class="javascript">const pool  = mysql.createPool(&#123;  connectionLimit : 10,// 一次性  host            : &#39;localhost&#39;,  user            : &#39;root&#39;,  port            : &#39;3306&#39;,  password        : &#39;123456&#39;,  database        : &#39;yanqi&#39;&#125;); var db = &#123;&#125;;db.p = function (sql,parm,callback) &#123;    // getConnection() 从连接池中获取链接     // 回参一：抛出错误    // 回参二：获取到的链接    pool.getConnection(function(error,connection)&#123;        if(error)&#123;            callback(error);// 错误异常处理            return // 获取链接池失败 以下不执行了        &#125;     // query()  往数据库发送请求的     // 参一：sql语句     // 参二：回调函数：处理数据库的响应     // 回参一：抛出错误异常（错误优先原则）     // 回参二：数据库响应的正确结果           connection.query(sql,parm,function(error,results)&#123;             console.log(`$&#123;sql&#125;===&gt;$&#123;parm&#125;`);             //  --&gt; 释放链接             connection.release();            //  ----&gt; 将操作数据库结果发送给外界让外处理             callback(error,results);// callback 是对查询结果的处理         &#125;)    &#125;)&#125;</code></pre><h5 id="getConnection"><a href="#getConnection" class="headerlink" title="getConnection()"></a>getConnection()</h5><h5 id="query"><a href="#query" class="headerlink" title="query()"></a>query()</h5><p>作用：通过连接池去操作去操作数据库</p><blockquote><p> 参一： sql 语句   换句话，如果想对数据是增删改查操作，就写对应的sql 语句</p></blockquote><blockquote><p> 参二： 回调函数：sql 语句执行的结果</p><p>——&gt;  回参一： 返回的是错误信息</p><p>——&gt;  回参二：sql 执行成功 输出的结果</p></blockquote><h3 id="mongoDB"><a href="#mongoDB" class="headerlink" title="mongoDB"></a>mongoDB</h3><ul><li>关系是数据库对应多个集合<ul><li>集合对应多个文档对象</li><li>在mongo中不论是db还是集合，你都无需去创建他</li><li>直接就当他已经存在，直接Use来使用<ul><li>use db名称;<ul><li>接着会被切换到该db中</li><li><code>db.要创建的集合名称.save(&#123;&#125;)</code>;这样集合就被创建了</li></ul></li></ul></li></ul></li><li>1:启动服务器<ul><li><code>mongod --dbpath &quot;D:/mongodb/db&quot;</code> &#x2F;&#x2F; 目录一定要存在自己创建随便名称‘<ul><li>尽量设置在非系统盘 <code>C盘生成目录是需要权限的</code></li></ul></li><li>如果看到<code>waiting for connections on port 27017</code>说明服务已经启动</li></ul></li><li>客户端连接服务器<strong>另开一个命令行</strong><ul><li><code>mongo</code> 默认连接的是test数据库</li></ul></li><li>查询有哪些数据库  <ul><li>查询数据库：<code>show dbs;</code></li><li>切换数据库: <code>use 数据库名;</code></li></ul></li><li>查询当前db下有哪些集合<ul><li><code>show collections;</code></li></ul></li><li>查询数据：<ul><li><code>db.集合名.find();</code>  &#x2F;&#x2F;查询出来的是文档对象 document</li><li><code>db.users.find();</code></li></ul></li><li>添加数据:<ul><li><code>db.集合名.save(对象)</code> &#x2F;&#x2F;mongo默认会给我们加入_id作为该文档对象的唯一标识</li><li><code>db.users.save(&#123;contry:&#39;中国&#39;,name:&#39;小明&#39;,score:77&#125;);</code></li></ul></li><li>删除数据:<ul><li><code>db.集合名.remove(条件对象);</code>&#x2F;&#x2F;条件匹配就会被删除</li><li><code>db.users.remove(&#123;name:&#39;小明&#39;&#125;);</code></li><li>如果给定一个空对像，会匹配全部</li></ul></li><li>更新数据:<ul><li><code>db.集合名.update(&#123;匹配条件对象&#125;,&#123;$set:&#123;修改后的对象&#125;&#125;);</code></li><li><code>db.users.update(&#123;name:&#39;小明&#39;&#125;,&#123;$set:&#123;contry:&#39;印度&#39;&#125;&#125;);;</code></li></ul></li></ul><h4 id="条件查询-1"><a href="#条件查询-1" class="headerlink" title="条件查询"></a>条件查询</h4><pre><code>练习：   查询姓名为小明的学生        db.users.find(&#123;name:&#39;小明&#39;&#125;);;   查询英语成绩大于90分的同学        db.users.find(&#123;score:&#123;$gt:90&#125;&#125;); //查找成绩大于90分$gt        //$lt小于   查询数学成绩不等于88的同学        db.users.find(&#123;score:&#123;$ne:88&#125;&#125;);   查询总分大于200分的所有同学        db.users.find(&#123;score:&#123;$gt:200&#125;&#125;);</code></pre><h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><ul><li><code>db.users.find().skip(3).limit(3);</code></li><li>db.集合名称.find().跳到3.显示3条<br>  ​    ​    ​    ​    + limit 0,3</li></ul><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><ul><li><code>db.users.find().sort(&#123;key:排序方式&#125;);</code></li><li><code>db.users.find().sort(&#123;&#39;score&#39;:1&#125;);</code> &#x2F;&#x2F;正数代表升序，负数代表降序</li></ul><h4 id="模糊匹配"><a href="#模糊匹配" class="headerlink" title="模糊匹配"></a>模糊匹配</h4><ul><li><code>db.users.find(&#123;name:&#123;$regex:&#39;小&#39;&#125;&#125;);</code></li><li><code>db.users.find(&#123;name:&#123;$regex:&#39;明&#39;&#125;&#125;);</code></li></ul><h4 id="聚合函数-1"><a href="#聚合函数-1" class="headerlink" title="聚合函数"></a>聚合函数</h4><ul><li><p>需要求当前集合的记录数：</p></li><li><p><code>db.users.find().count();</code></p></li><li><p>求最大值<br>  -求整个集合的总成绩<br>  ​    + db.集合名.聚合({ 组的划分规则{_id:’1’,显示内容:{$sum:’$score’}} })</p><ul><li>求所有人的平均分<ul><li><code>db.users.aggregate(&#123;$group:&#123;_id:&#39;1&#39;,sumscore:&#123;$avg:&#39;$score&#39; &#125; &#125;&#125;);</code></li></ul></li><li>求按国家分组，求所有国家的总分<ul><li><code>db.users.aggregate(&#123;$group:&#123;_id:&#39;$contry&#39;,sumScore:&#123;$sum:&#39;$score&#39;&#125;&#125;&#125;);</code></li></ul></li></ul></li><li><p>添加基础数据:<br>  db.users.save({contry:’中国’,name:’小明’,score:77});<br>  db.users.save({contry:’中国’,name:’小红’,score:88});<br>  db.users.save({contry:’中国’,name:’小张’,score:99});<br>  db.users.save({contry:’美国’,name:’jack’,score:45});<br>  db.users.save({contry:’美国’,name:’rose’,score:67});<br>  db.users.save({contry:’美国’,name:’mick’,score:89});</p></li></ul><p>解决32位异常<br>mongod –dbpath&#x3D;”路径” –journal –storageEngine&#x3D;mmapv1</p><h3 id="mongoose"><a href="#mongoose" class="headerlink" title="mongoose"></a>mongoose</h3><h3 id="mySQL与-mongoDB-区别"><a href="#mySQL与-mongoDB-区别" class="headerlink" title="mySQL与 mongoDB 区别"></a>mySQL与 mongoDB 区别</h3><p>1：mysql 是关系型数据库  mongoDB 是非关系型</p><p>2: mysql 需要自己创建连接池 操作数据库 ，mongoDB 内部自带连接池</p><p>3: 概念区分：</p><p>​    myql 数据库&#x2F;表&#x2F;字段  </p><p>​    mongoDB  数据库&#x2F;集合&#x2F;文档最对象</p><p>4：操作数据：</p><ul><li>mysql  必须先创建数据库—&gt;创建表—&gt; 字段——&gt;字段值的数据类型    这些必须在操作数据之前准备好 中间 字段有改变时候，必须要通过表来改变。不能通过操作数据的sql语句来修改</li><li>mongoDB 创建数据库 ,集合以及文档对象，都可以通过操作数据的命令来创建或者修改。使用’命令行‘时，如果没有集合则会自动创建，有 则对集合中文档对象操作</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用 Git 命令总结</title>
      <link href="/2022/09/07/Git/"/>
      <url>/2022/09/07/Git/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Git 是我们日常工作中使用频率极高的工具，各种指令让人眼花缭乱，今天，我们就在这里总结一下它的一些基本指令，算是做一份操作笔记吧。</p><h2 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h2><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><p>把要提交的文件的信息添加到暂存区中。当使用 git commit 时，将依据暂存区中的内容来进行文件的提交。</p><p>它通常将现有路径的当前内容作为一个整体添加，但是通过一些选项，它也可以用于添加内容，只对所应用的工作树文件进行一些更改，或删除工作树中不存在的路径了。</p><p>“索引”保存工作树内容的快照，并且将该快照作为下一个提交的内容。 因此，在对工作树进行任何更改之后，并且在运行 <code>git commit</code> 命令之前，必须使用 <code>git add</code> 命令将任何新的或修改的文件添加到索引。</p><p>该命令可以在提交之前多次执行。它只在运行 <code>git add</code> 命令时添加指定文件的内容; 如果希望随后的更改包含在下一个提交中，那么必须再次运行 <code>git add</code> 将新的内容添加到索引。</p><pre><code class="bash"># 把指定的文件添加到暂存区中$ git add &lt;文件路径&gt;# 添加所有修改、已删除的文件到暂存区中$ git add -u [&lt;文件路径&gt;]$ git add --update [&lt;文件路径&gt;]# 添加所有修改、已删除、新增的文件到暂存区中，省略 &lt;文件路径&gt; 即为当前目录$ git add -A [&lt;文件路径&gt;]$ git add --all [&lt;文件路径&gt;]# 查看所有修改、已删除但没有提交的文件，进入一个子命令系统$ git add -i [&lt;文件路径&gt;]$ git add --interactive [&lt;文件路径&gt;]</code></pre><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><p>操作 Git 的分支命令。</p><pre><code class="bash"># 列出本地的所有分支，当前所在分支以 &quot;*&quot; 标出$ git branch# 列出本地的所有分支并显示最后一次提交，当前所在分支以 &quot;*&quot; 标出$ git branch -v# 创建新分支，新的分支基于上一次提交建立$ git branch &lt;分支名&gt;# 修改分支名称# 如果不指定原分支名称则为当前所在分支$ git branch -m [&lt;原分支名称&gt;] &lt;新的分支名称&gt;# 强制修改分支名称$ git branch -M [&lt;原分支名称&gt;] &lt;新的分支名称&gt;# 删除指定的本地分支$ git branch -d &lt;分支名称&gt;# 强制删除指定的本地分支$ git branch -D &lt;分支名称&gt;</code></pre><h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><p>更新工作树中的文件以匹配索引或指定树中的版本。如果没有给出路径 - <code>git checkout</code> 还会更新 <code>HEAD</code> ，将指定的分支设置为当前分支。</p><pre><code class="bash"># 切换到已存在的指定分支$ git checkout &lt;分支名称&gt;# 创建并切换到指定的分支，保留所有的提交记录# 等同于 &quot;git branch&quot; 和 &quot;git checkout&quot; 两个命令合并$ git checkout -b &lt;分支名称&gt;# 创建并切换到指定的分支，删除所有的提交记录$ git checkout --orphan &lt;分支名称&gt;# 替换掉本地的改动，新增的文件和已经添加到暂存区的内容不受影响$ git checkout &lt;文件路径&gt;</code></pre><blockquote><p><code>git checkout</code> 是 git 最常用的命令之一，同时也是一个很危险的命令，因为这条命令会重写工作区。</p></blockquote><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><p>将存储库克隆到新创建的目录中，为克隆的存储库中的每个分支创建远程跟踪分支(使用 <code>git branch -r</code> 可见)，并从克隆检出的存储库作为当前活动分支的初始分支。</p><pre><code class="bash"># 默认在当前目录下创建和版本库名相同的文件夹并下载版本到该文件夹下$ git clone &lt;远程仓库的网址&gt;# 指定本地仓库的目录$ git clone &lt;远程仓库的网址&gt; &lt;本地目录&gt;# -b 指定要克隆的分支，默认是master分支$ git clone &lt;远程仓库的网址&gt; -b &lt;分支名称&gt; &lt;本地目录&gt;</code></pre><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p>将索引的当前内容与描述更改的用户和日志消息一起存储在新的提交中。</p><pre><code class="bash"># 把暂存区中的文件提交到本地仓库，调用文本编辑器输入该次提交的描述信息$ git commit# 把暂存区中的文件提交到本地仓库中并添加描述信息$ git commit -m &quot;&lt;提交的描述信息&gt;&quot;# 把所有修改、已删除的文件提交到本地仓库中# 不包括未被版本库跟踪的文件，等同于先调用了 &quot;git add -u&quot;$ git commit -a -m &quot;&lt;提交的描述信息&gt;&quot;# 修改上次提交的描述信息$ git commit --amend</code></pre><h3 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h3><p>主要是用来配置 Git 的相关参数，其主要操作有：</p><pre><code class="bash"># 查看配置信息# --local：仓库级，--global：全局级，--system：系统级$ git config &lt;--local | --global | --system&gt; -l# 查看当前生效的配置信息$ git config -l# 编辑配置文件# --local：仓库级，--global：全局级，--system：系统级$ git config &lt;--local | --global | --system&gt; -e# 添加配置项# --local：仓库级，--global：全局级，--system：系统级$ git config &lt;--local | --global | --system&gt; --add &lt;name&gt; &lt;value&gt;# 获取配置项$ git config &lt;--local | --global | --system&gt; --get &lt;name&gt;# 删除配置项$ git config &lt;--local | --global | --system&gt; --unset &lt;name&gt;# 配置提交记录中的用户信息$ git config --global user.name &lt;用户名&gt;$ git config --global user.email &lt;邮箱地址&gt;# 更改Git缓存区的大小# 如果提交的内容较大，默认缓存较小，提交会失败# 缓存大小单位：B，例如：524288000（500MB）$ git config --global http.postBuffer &lt;缓存大小&gt;# 调用 git status/git diff 命令时以高亮或彩色方式显示改动状态$ git config --global color.ui true# 配置可以缓存密码，默认缓存时间15分钟$ git config --global credential.helper cache# 配置密码的缓存时间# 缓存时间单位：秒$ git config --global credential.helper &#39;cache --timeout=&lt;缓存时间&gt;&#39;# 配置长期存储密码$ git config --global credential.helper store</code></pre><blockquote><p>Git 一共有3个配置文件：  </p></blockquote><ol><li>仓库级的配置文件：在仓库的 <code>.git/.gitconfig</code>，该配置文件只对所在的仓库有效。</li><li>全局配置文件：Mac 系统在 <code>~/.gitconfig</code>，Windows 系统在 <code>C:\Users\&lt;用户名&gt;\.gitconfig</code>。</li><li>系统级的配置文件：在 Git 的安装目录下（Mac 系统下安装目录在 <code>/usr/local/git</code>）的 <code>etc</code> 文件夹中的 <code>gitconfig</code>。</li></ol><h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><p>用于显示提交和工作树等之间的更改。</p><p>此命令比较的是工作目录中当前文件和暂存区域快照之间的差异,也就是修改之后还没有暂存起来的变化内容。</p><pre><code class="bash"># 比较当前文件和暂存区中文件的差异，显示没有暂存起来的更改$ git diff# 比较暂存区中的文件和上次提交时的差异$ git diff --cached$ git diff --staged# 比较当前文件和上次提交时的差异$ git diff HEAD# 查看从指定的版本之后改动的内容$ git diff &lt;commit ID&gt;# 比较两个分支之间的差异$ git diff &lt;分支名称&gt; &lt;分支名称&gt;# 查看两个分支分开后各自的改动内容$ git diff &lt;分支名称&gt;...&lt;分支名称&gt;</code></pre><h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><p>从远程仓库获取最新的版本到本地的 tmp 分支上。</p><pre><code class="bash"># 将远程仓库所有分支的最新版本全部取回到本地$ git fetch &lt;远程仓库的别名&gt;# 将远程仓库指定分支的最新版本取回到本地$ git fetch &lt;远程主机名&gt; &lt;分支名&gt;</code></pre><h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><p>初始化项目所在目录，初始化后会在当前目录下出现一个名为 .git 的目录。</p><pre><code class="bash"># 初始化本地仓库，在当前目录下生成 .git 文件夹$ git init</code></pre><h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><p>显示提交的记录。</p><pre><code class="bash"># 打印所有的提交记录$ git log# 打印从第一次提交到指定的提交的记录$ git log &lt;commit ID&gt;# 打印指定数量的最新提交的记录$ git log -&lt;指定的数量&gt;</code></pre><h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><p>用于将两个或两个以上的开发历史加入(合并)一起。</p><pre><code class="bash"># 把指定的分支合并到当前所在的分支下，并自动进行新的提交$ git merge &lt;分支名称&gt;# 把指定的分支合并到当前所在的分支下，不进行新的提交$ git merge --no-commit &lt;分支名称&gt;</code></pre><h3 id="git-mv"><a href="#git-mv" class="headerlink" title="git mv"></a>git mv</h3><p>重命名文件或者文件夹。</p><pre><code class="bash"># 重命名指定的文件或者文件夹$ git mv &lt;源文件/文件夹&gt; &lt;目标文件/文件夹&gt;</code></pre><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p>从远程仓库获取最新版本并合并到本地。 首先会执行 <code>git fetch</code>，然后执行 <code>git merge</code>，把获取的分支的 HEAD 合并到当前分支。</p><pre><code class="bash"># 从远程仓库获取最新版本。$ git pull</code></pre><h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p>把本地仓库的提交推送到远程仓库。</p><pre><code class="bash"># 把本地仓库的分支推送到远程仓库的指定分支$ git push &lt;远程仓库的别名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;# 删除指定的远程仓库的分支$ git push &lt;远程仓库的别名&gt; :&lt;远程分支名&gt;$ git push &lt;远程仓库的别名&gt; --delete &lt;远程分支名&gt;</code></pre><h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><p>操作远程库。</p><pre><code class="bash"># 列出已经存在的远程仓库$ git remote# 列出远程仓库的详细信息，在别名后面列出URL地址$ git remote -v$ git remote --verbose# 添加远程仓库$ git remote add &lt;远程仓库的别名&gt; &lt;远程仓库的URL地址&gt;# 修改远程仓库的别名$ git remote rename &lt;原远程仓库的别名&gt; &lt;新的别名&gt;# 删除指定名称的远程仓库$ git remote remove &lt;远程仓库的别名&gt;# 修改远程仓库的 URL 地址$ git remote set-url &lt;远程仓库的别名&gt; &lt;新的远程仓库URL地址&gt;</code></pre><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p>还原提交记录。</p><pre><code class="bash"># 重置暂存区，但文件不受影响# 相当于将用 &quot;git add&quot; 命令更新到暂存区的内容撤出暂存区，可以指定文件# 没有指定 commit ID 则默认为当前 HEAD$ git reset [&lt;文件路径&gt;]$ git reset --mixed [&lt;文件路径&gt;]# 将 HEAD 的指向改变，撤销到指定的提交记录，文件未修改$ git reset &lt;commit ID&gt;$ git reset --mixed &lt;commit ID&gt;# 将 HEAD 的指向改变，撤销到指定的提交记录，文件未修改# 相当于调用 &quot;git reset --mixed&quot; 命令后又做了一次 &quot;git add&quot;$ git reset --soft &lt;commit ID&gt;# 将 HEAD 的指向改变，撤销到指定的提交记录，文件也修改了$ git reset --hard &lt;commit ID&gt;</code></pre><h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h3><p>生成一个新的提交来撤销某次提交，此次提交之前的所有提交都会被保留。</p><pre><code class="bash"># 生成一个新的提交来撤销某次提交$ git revert &lt;commit ID&gt;</code></pre><h3 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h3><p>删除文件或者文件夹。</p><pre><code class="bash"># 移除跟踪指定的文件，并从本地仓库的文件夹中删除$ git rm &lt;文件路径&gt;# 移除跟踪指定的文件夹，并从本地仓库的文件夹中删除$ git rm -r &lt;文件夹路径&gt;# 移除跟踪指定的文件，在本地仓库的文件夹中保留该文件$ git rm --cached</code></pre><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><p>用于显示工作目录和暂存区的状态。使用此命令能看到那些修改被暂存到了, 哪些没有, 哪些文件没有被 Git tracked 到。</p><pre><code class="bash"># 查看本地仓库的状态$ git status</code></pre><blockquote><p><code>git status</code> 不显示已经 <code>commit</code> 到项目历史中去的信息。<br>看项目历史的信息要使用 <code>git log</code>。</p></blockquote><h3 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h3><p>操作标签的命令。</p><pre><code class="bash"># 打印所有的标签$ git tag# 添加轻量标签，指向提交对象的引用，可以指定之前的提交记录$ git tag &lt;标签名称&gt; [&lt;commit ID&gt;]# 添加带有描述信息的附注标签，可以指定之前的提交记录$ git tag -a &lt;标签名称&gt; -m &lt;标签描述信息&gt; [&lt;commit ID&gt;]# 切换到指定的标签$ git checkout &lt;标签名称&gt;# 查看标签的信息$ git show &lt;标签名称&gt;# 删除指定的标签$ git tag -d &lt;标签名称&gt;# 将指定的标签提交到远程仓库$ git push &lt;远程仓库的别名&gt; &lt;标签名称&gt;# 将本地所有的标签全部提交到远程仓库$ git push &lt;远程仓库的别名&gt; –tags</code></pre>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>blog</title>
      <link href="/2022/08/19/blog/"/>
      <url>/2022/08/19/blog/</url>
      
        <content type="html"><![CDATA[<h1 id="Blog"><a href="#Blog" class="headerlink" title="Blog"></a>Blog</h1><p>代码测试：<br>`&#96;&#96;py<br>print(“Hello”)<br>`&#96;&#96;</p><p>注意：这里因为我放在md文件中的，所以加上了\，不解析&#96;&#96;&#96;，实际测试时请去掉\。</p><p>图片测试：</p><p><img src="http://mculover666.cn/blog/20191031/R4mWMXsrRKxu.png?imageslim"></p><p>引用测试：</p><blockquote><p>这是一条引用</p></blockquote><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p>无序列表测试：</p><ul><li>哈哈</li><li>嘿嘿</li><li>吼吼</li></ul><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/08/18/hello-world/"/>
      <url>/2022/08/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
